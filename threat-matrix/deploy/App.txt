<!DOCTYPE html>
<html>
<head>
    <title>Threat Matrix</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Mon Aug 10 2015 16:43:23 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Aug 10 2015 16:43:23 GMT-0700 (PDT)";
        var CHECKSUM = 49576820774;
    </script>

   <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>


    <script type="text/javascript">
        if (!window.location.origin) {
            window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
        }
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        //console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        var i = -1, l = arguments.length, args = [], fn = 'console.log(args)';
        while(++i<l){
            args.push('args['+i+']');
        };
        fn = new Function('args',fn.replace(/args/,args.join(',')));
        //fn(arguments);
    }

});

Ext.define('Rally.technicalservices.ThreatCalculator', {
    logger: new Rally.technicalservices.Logger(),

    /**
     * @cfg {Number}
     * Colors to be applied in order (must be HSLA)
     * We'll take them and put them into the first part of:
     * 'hsla(235,100%,75%,1)'
     * where 25 is the color, 100% is the saturation, 75% is the lightness (100% is white), 1 is the opacity
     *
     * NICE SITE: http://hslpicker.com/
     *
     */
    colors: [209, 235, 20, 126, 180, 50, 84 ],


    chartColors: [ '#2f7ed8', '#8bbc21', '#910000',
        '#492970', '#f28f43', '#145499','#77a1e5', '#c42525', '#a6c96a',
        '#7cb5ec', '#434348', '#90ed7d', '#f7a35c', '#8085e9','#aa1925',
        '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1','#1aadce',
        '#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
        '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],

    dependencyColors: ['#FF0000','#00FF00','#0000FF','#00FFFF', '#FFFF00','#FF00FF','#FF9966','#6600FF','#996633'],
    genericDependencyColor: '#000000',
    noDependencyColor: '#FFFFFF',

    config: {
        riskField: undefined,
        currentProjectRef: undefined,
        projects: undefined,
        maxFeatureAgeThreshhold: undefined,
        maxStoryAgeThreshhold: undefined,
        minAgeThreshhold: undefined,
        minPointsThreshhold: undefined,
        minSize: 3,
        andMinThreshholds: true,
        featureSizeMultiplier: undefined,
        storySizeMultiplier: undefined,
        riskMultiplier: undefined,
        iterationDays: undefined,
        releaseDays: undefined,
        showDataLabels: false,
        showDependencyColors: false,
        programRiskSize: undefined
    },
    /**
     * projectTree is used to show the hierarchy of the projects so that we can
     * determine which items to show (vs. which to include in the calculations)
     */
    projectTree: {},
    dependencyLineWidth: 2,
    dependencyMap: {},
    defaultColor: '#C0C0C0',
    colorMap: {},

    /**
     *     Symbol for anything not in the symbol map;
     *     I'm intentionally keeping features out of the symbol map and
     *     making the symbol the default since names can change.  If we
     *     add tasks to this chart, then we will add the tAsk object to
     *     the SymbolMap
     */
    defaultSymbol: "square",
    symbolMap: {
        hierarchicalrequirement: "circle"
    },
    sizeMultiplierMap: {
        hierarchicalrequirement: 2
    },
    constructor: function (config) {
        this.mergeConfig(config);
        this.projectTree = this._getTreeArray(config.projects, config.currentProjectRef);
        this.colorMap = this._buildColorMap(this.projectTree);
    },
    runCalculation: function(features, stories){
        var deferred = Ext.create('Deft.Deferred');

        var featureStoryHash = {},
            promises = [];

        _.each(stories, function(s){

            s.set('riskCount', this._getRiskScore(s));
            s.set('totalCount', 1);
            s.set('size', s.get('PlanEstimate') );
            s.set('density', this._getStoryDensity(s));
            s.set('age', this._getAge(s, 'InProgressDate', this.maxStoryAgeThreshhold));
            if (s.get('Feature')){
                featureStoryHash[s.get('Feature')._ref] = featureStoryHash[s.get('Feature')._ref] || [];
                featureStoryHash[s.get('Feature')._ref].push(s);
            }
            if (this._includeInChart(s)){
                promises.push(this._getPredecessors(s));
            }
        }, this);

        _.each(features, function(f){
            var riskCount = 0, totalCount = 0;
            f.set('age', this._getAge(f, 'ActualStartDate', this.maxFeatureAgeThreshhold));
            _.each(featureStoryHash[f.get('_ref')], function(s){
                totalCount ++;
                riskCount+= s.get('riskCount');
            }, this);
            f.set('riskCount', riskCount);
            f.set('totalCount', totalCount);
            f.set('size', f.get('LeafStoryPlanEstimateTotal'));
            if (f.get(this.riskField)){
                f.set('density', 100);
            } else if (totalCount > 0){
                f.set('density', riskCount/totalCount * 100);
            } else {
                f.set('density', 0);
            }
            f.set('predecessorFids', []);
        }, this);

        if (promises.length > 0){
            Deft.Promise.all(promises).then({
                scope: this,
                success: function(){
                    var artifacts = features.concat(stories);
                    this.logger.log('predecessors loaded', artifacts);
                    var series = [];
                    _.each(artifacts, function(a){
                        if (this._includeInChart(a)){
                            series.push(this._getSeries(a));
                        }
                    }, this);
                    this.logger.log('predecessors loaded -- series', series);
                    deferred.resolve({series: series});
                },
                failure: function(operation){
                    deferred.reject(operation);
                }
            });
        } else {

            var artifacts = features.concat(stories);
            this.logger.log('predecessors loaded', artifacts);

            var series = [];
            _.each(artifacts, function(a){
                if (this._includeInChart(a)){
                    series.push(this._getSeries(a));
                }
            }, this);
            this.logger.log('predecessors loaded -- series', series);
            deferred.resolve({series: series});

        }
        return deferred;
        //return {series: series};
    },
    _getPredecessors: function(artifact){
        this.logger.log('_getPredecessors', artifact.get('Predecessors'));
        var deferred = Ext.create('Deft.Deferred');

        if (artifact.get('Predecessors') && artifact.get('Predecessors').Count > 0 ){
            artifact.getCollection('Predecessors').load({
                scope: this,
                fetch: ['FormattedID'],
                callback: function(records, operation, success){
                    this.logger.log('predecessor store loaded', artifact.get('FormattedID'), success, records, operation);
                    var predecessorOids = [];
                    if (success) {
                        _.each(records, function(r){
                            if (!_.has(this.dependencyMap, r.get('FormattedID'))){
                                var color_index = _.keys(this.dependencyMap).length % this.dependencyColors.length;
                                this.dependencyMap[r.get('FormattedID')] = this.dependencyColors[color_index];
                            }
                            predecessorOids.push(r.get('FormattedID'));
                        }, this);
                        artifact.set('predecessorFids', predecessorOids);
                        deferred.resolve();
                    } else {
                        deferred.resolve(operation);
                    }
                }
            });
        } else {
            artifact.set('predecessorFids',[]);
            deferred.resolve();
        }
        return deferred;
    },
    _includeInChart: function(artifact) {
        //Check project scope
        var projectRef = artifact.get('Project')._ref;

        var include = this.projectTree.get('_ref') == projectRef;
        if (!include) {
            _.each(this.projectTree.get('Children'), function (child) {
                if (child.get('_ref') == projectRef) {
                    include = true;
                    return false; //kick us out of the _.each link
                }
            }, this);
        }

        if (!include) { //Don't go any further
            return false;
        }

        if (this._isProgramLevelRisk(artifact)){
            return true;
        }

        var size = artifact.get('size'),
            age = artifact.get('age');

        if (this.andMinThreshholds && (size < this.minPointsThreshhold) && (age < this.minAgeThreshhold)) {
            return false;
        }
        return (size >= this.minPointsThreshhold) || (age >= this.minAgeThreshhold);

    },
    _buildColorMap: function(projectTree){
        var colorMap = {},
            projectLabelColorMap = {},
            i=0;

        //We only need to do this for the current and child projects since we are only looking at one
        //level of hierarchy at a time.
        colorMap[projectTree.get('_ref')] = this.chartColors[i++];
        projectLabelColorMap[projectTree.get('Name')] = colorMap[projectTree.get('_ref')];
        _.each(projectTree.get('Children'), function(child){
            colorMap[child.get('_ref')] = this.chartColors[i++];
            projectLabelColorMap[child.get('Name')] = colorMap[child.get('_ref')];
        }, this);
        this.projectLabelColorMap = projectLabelColorMap;
        return colorMap;
    },
    _isProgramLevelRisk: function(artifact){
        return  (this._isArtifactUserStory(artifact) == false &&
            artifact.get(this.riskField) == true &&
            artifact.get('LeafStoryCount') == 0 &&
            !artifact.get('Parent'));
    },
    _getSeries: function(artifact){
        this.logger.log('id, size, age, density',artifact.get('FormattedID'),artifact.get('size'),artifact.get('age'), artifact.get('density'),artifact.get('predecessorFids'))

        var isUserStory = this._isArtifactUserStory(artifact),
            color = this._getColor(artifact),
            hasDependency = artifact.get('predecessorFids') ? (artifact.get('predecessorFids').length > 0) : false,
            isDependencyColor = this.noDependencyColor,
            isDependencyWidth = 0,
            dependencies = [],
            isProgramLevelRisk = this._isProgramLevelRisk(artifact);


        var pointName = Ext.String.format("Project: {1}<br/>Size: {2}<br/>Age (days): {3}", artifact.get('FormattedID'),
                artifact.get('Project').Name,
                artifact.get('size'), artifact.get('age').toFixed(1));

        if (isProgramLevelRisk){
            isDependencyWidth = Math.max(this.programRiskSize-2, 1);
            isDependencyColor = color;
            color = '#FFFFFF';
            pointName = Ext.String.format("<b>Program Level Risk</b><br/>Project: {0}",
                artifact.get('Project').Name);
        }

        if (hasDependency){
            dependencies = artifact.get('predecessorFids').slice();
            pointName = Ext.String.format('{0}<br/>Dependencies [{1}]',pointName, dependencies.join(','));
        }
        if (_.has(this.dependencyMap, artifact.get('FormattedID'))){
            isDependencyColor = this.showDependencyColors ? this.dependencyMap[artifact.get('FormattedID')] || this.genericDependencyColor : this.genericDependencyColor;
            isDependencyWidth = this.dependencyLineWidth;
        }


        return {
            marker: {
                radius: this._getRadius(artifact),
                symbol: this._getSymbol(artifact),
                fillColor: color,
                lineColor: isDependencyColor,
                lineWidth: isDependencyWidth,
                states: {
                    select: {
                        fillColor: color,
                        lineColor: isDependencyColor,
                        lineWidth: isDependencyWidth
                    }
                }
            },
            color: color,
            name: artifact.get('FormattedID'),
            tooltip: {
                pointFormat: pointName,
                borderColor: '#000000'
            },
            dataLabels: {
                enabled: this.showDataLabels,
                color: 'black'
            },
            data: [{
                x: artifact.get('age'),
                y: artifact.get('density'),
                dependencies: dependencies,
                artifact: artifact.getData(),
                paths: []
            }],
            showInLegend: false,
            allowPointSelect: true,
            yAxis: isUserStory ? 1 : 0,
            xAxis: isUserStory ? 1 : 0,
            point: {
                events: {
                    click: this._pointClick,
                    select: this._drawDependency,
                    unselect: this._drawDependency
                }
            }
        };
    },
    
    _pointClick: function(evt) {
        var point = evt.point;
        if ( evt.altKey ) {
            //console.log('alt click', point, evt);
            Rally.nav.Manager.showDetail(point.artifact._ref);
        }
    },
    
    _drawDependency: function(evt, point){
        if (!point){
            point = this;
        }
        this.paths = this.paths || [];

       if (evt.type == 'select' && this.paths.length == 0){

           var ren = this.series.chart.renderer;
           var plotLeft = point.series.chart.plotLeft,
                plotTop = point.series.chart.plotTop,
                x1 = point.series.points[0].plotX + plotLeft,
                y1 = point.series.points[0].plotY + plotTop,
                thisName = point.series.name,
                thisColor = point.series.options.marker.lineColor,
                thisRadius = point.series.options.marker.radius,
                    pointPaths = [];

                _.each(point.series.chart.series, function(s){
                    if (Ext.Array.contains(s.data[0].dependencies, thisName)){

                        var delta_y = y1 - (s.points[0].plotY + plotTop),
                            delta_x = x1 - (s.points[0].plotX + plotLeft),
                            dist = Math.sqrt(Math.pow((delta_x),2) + Math.pow((delta_y),2));

                        var ratio1 =  -thisRadius/dist,
                            dep_x = ratio1 * (delta_x) + x1,
                            dep_y = ratio1 * (delta_y) + y1;

                        var rad = s.options.marker.radius;
                        var ratio2 = (rad-dist)/dist,
                            pred_x = ratio2 * delta_x + x1,
                            pred_y = ratio2 * delta_y + y1;

                        pointPaths.push(ren.path(['M',dep_x, dep_y , 'L', pred_x, pred_y]) //s.points[0].plotX + plotLeft, s.points[0].plotY + plotTop])
                            .attr({
                                'stroke-width': 1,
                                stroke: thisColor,
                                'stroke-opacity': 0.5,
                                itemId: 'path-' + thisName
                            })
                            .add());
                    }
                }, this);
                this.paths = pointPaths;
            }

            if (evt.type == 'unselect'){
                _.each(this.paths, function(p) {
                    var parent = p.element.parentNode;
                    parent.removeChild(p.element);
                });
                this.paths = [];
            }
    },
    _getRadius: function(artifact){
        if (this._isProgramLevelRisk(artifact)){
            return this.programRiskSize;
        }

        var multiplier = this._isArtifactUserStory(artifact) ? this.storySizeMultiplier || 1 : this.featureSizeMultiplier || 1;
        return Math.max(artifact.get('size') * multiplier || 0, this.minSize);
    },
    _getColor: function(artifact){
        var hexColor = this.colorMap[artifact.get('Project')._ref] || this.defaultColor;
        var alpha = 1;
        if (this._isArtifactUserStory(artifact)){
            alpha = .5;
        }
        return this._hexToRGBAColorString(hexColor, alpha);
    },
    _getSymbol: function(artifact){
        return "circle"; //this.symbolMap[artifact.get('_type')] || "square";
    },
    _getStoryDensity: function(story){
        var multiplier = this._getRiskScore(story) > 0 ? this.riskMultiplier || 1 : 1;
        return story.get('PlanEstimate') * multiplier;
     },
    _getRiskScore: function(story){
        return story.get(this.riskField) > 0 ? 1 : 0;
    },
    _getAge: function(artifact, ageField, maxThreshhold){
       var ageInHours = Rally.util.DateTime.getDifference(new Date(), Rally.util.DateTime.fromIsoString(artifact.get(ageField)), 'hour') || 0,
           ageInDays = ageInHours / 24;
        return Math.min(ageInDays, maxThreshhold);
   },
    _hexToRGBAColorString: function(hex, alpha) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

        if (result){
            return Ext.String.format("rgba({0},{1},{2},{3})",
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16),
                alpha
            );
        }
        return hex;
    },
    _isArtifactUserStory: function(artifact){
        return artifact.get('_type') == 'hierarchicalrequirement';
    },
    _getTreeArray:function(records, currentProjectRef) {

        var projectHash = {};
        _.each(records, function(rec){
            projectHash[rec.get('ObjectID')] = rec;

        });
        var current_root = null;


        var root_array = [];
        Ext.Object.each(projectHash, function(oid,item){

            if ( !item.get('Children') ) { item.set('Children',[]); }
            var direct_parent = item.get('Parent');
            if (!direct_parent && !Ext.Array.contains(root_array,item)) {
                root_array.push(item);
            } else {

                var parent_oid =  direct_parent.ObjectID || direct_parent.get('ObjectID');

                if (!projectHash[parent_oid]) {
                    if ( !Ext.Array.contains(root_array,item) ) {
                        root_array.push(item);
                    }
                } else {
                    var parent = projectHash[parent_oid];
                    if ( !parent.get('Children') ) { parent.set('Children',[]); }
                    var kids = parent.get('Children');
                    kids.push(item);
                    parent.set('Children',kids);
                }
            }
            if (item.get('_ref') == currentProjectRef){
                current_root = item;
            }
        },this);

        return current_root;
    }
});
Ext.define('Rally.technicalservices.ThreatChart',{
    extend: 'Rally.ui.chart.Chart',
    alias: 'widget.tsthreatchart',

    chartData: {},

    chartConfig: {
        loadMask: false,
        chart: {

            type: 'scatter',
            zoom: 'xy'
            //events: {
            //    load: function(){
            //        _.each(this.series, function(s){
            //            console.log('chart load', s);
            //        });
            //
            //    }
            //}
        },
        title: {
            text: 'Threat Matrix'
        },
        legend: {
            enabled: false
        },
        xAxis: [{
            min: 0,
            title: {
                text: 'Feature Age (Days)'
            },
            opposite: true,
            startOnTick: true,
            endOnTick: true,
            showLastLabel: true
        },{
            title: {
                text: 'User Story Age (Days)'
            },
            min: 0,
            startOnTick: true,
            endOnTick: true,
            showLastLabel: true
        }],
        yAxis: [
            {
                max: 110,
                min: 0,
                title: {
                    text: '%Density (Feature)'
                },
                opposite: true
            },
            {
                title: {
                    text: 'Weighted Risk (User Story)'
                },
                min: 0
            }
        ],
        plotOptions: {
            series: {
                dataLabels: {
                    formatter: function(){return this.series.name;},
                    inside: true
                },
                tooltip: {
                    borderColor: 'black'
                }
            }
        }


      },
    constructor: function (config) {
        this.callParent(arguments);
        if (config.title){
            this.chartConfig.title = config.title;
        }
    },
    onRender: function () {
        this.callParent(arguments);
        this.getEl().unmask();
    }
});

Ext.define("threat-matrix", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    items: [
        {xtype:'tsinfolink',minHeight: 14,informationHtml:'Alt-click on a point to open its details page'},
        {xtype:'container',itemId:'settings_box'},
        {xtype:'container', itemId:'selector_box' }
    ],

    config: {
        defaultSettings: {
            minAgeThreshhold:  1,
            maxFeatureAgeThreshhold: 56,
            maxStoryAgeThreshhold: 14,
            minPointsThreshhold: 1,
            andMinThreshholds: true,
            featureSizeMultiplier: 1,
            storySizeMultiplier: 1,
            riskMultiplier: 2,
            showDataLabels: true,
            showDependencyColors: false,
            showScopeSelector: true,
            programRiskSize: 10
        }
    },
    storyFetchFields: ['FormattedID','c_Risk','PlanEstimate','Project','ScheduleState','InProgressDate','Blocked','Blocker','CreationDate','Feature','Name','Predecessors'],
    featureFetchFields: ['FormattedID','Project','ActualStartDate','ActualEndDate','LeafStoryPlanEstimateTotal', 'LeafStoryCount','Name', 'c_Risk', 'Parent'], //,'Predecessors'],
    portfolioItemFeature: 'PortfolioItem/Feature',
    projectFetchFields: ['Name','Parent','ObjectID'],
    riskField: 'c_Risk',
    ageGranularity: 'day',

    selectedIteration: null,
    selectedRelease: null,

    launch: function() {
         if (this.isExternal()){
            this.showSettings(this.config);
        } else {
            this.onSettingsUpdate(this.getSettings());
        }
    },

    getReleaseFilters: function(release){

        if (!release){
            release = this.getReleaseRecord();
        }

        return [{
            property: 'Release.Name',
            value: release.get('Name')
        },{
            property: 'Release.ReleaseStartDate',
            value: Rally.util.DateTime.toIsoString(release.get('ReleaseStartDate'))
        },{
            property: 'Release.ReleaseDate',
            value: Rally.util.DateTime.toIsoString(release.get('ReleaseDate'))
        }];
    },

    getStoryFilters: function(release, iteration){
        this.logger.log('getStoryFilters',release,iteration);
        var filters = this.getReleaseFilters(release);

        filters = filters.concat([{
            property: 'ScheduleState',
            value: 'In-Progress'
        }]);

        if (iteration){
            var iteration_start_date = Rally.util.DateTime.toIsoString(iteration.get('StartDate')),
                iteration_end_date = Rally.util.DateTime.toIsoString(iteration.get('EndDate'));

            filters = filters.concat([{
                property: 'Iteration.StartDate',
                value: iteration_start_date
            },{
                property: 'Iteration.EndDate',
                value: iteration_end_date
            },{
                property: 'Iteration.Name',
                value: iteration.get('Name')
            }]);
        }

        filters = Rally.data.wsapi.Filter.and(filters);

        this.logger.log('filters', filters.toString());
        return filters;
    },
    
    onTimeboxScopeChange: function(newTimeboxScope) {
        this.logger.log('newTimeboxScope',newTimeboxScope);
        if ( ! Ext.isEmpty(newTimeboxScope) ) {
            this.getBody().removeAll();
            if ((newTimeboxScope) && (newTimeboxScope.get('_type') === 'iteration')) {
                this.selectedIteration = newTimeboxScope;
            }
            if ((newTimeboxScope) && (newTimeboxScope.get('_type') === 'release')) {
                this.selectedRelease = newTimeboxScope;
            }
            if (this.selectedIteration || this.selectedRelease){
                this.run(this.selectedRelease, this.selectedIteration);
            } else {
                this.getBody().add({
                    xtype: 'container',
                    html: Ext.String.format('Please select Release to view the Threat Matrix')
                });
            }
        }
    },

    run: function(release, iteration){

        this.logger.log('run',release, iteration);
        
        if ( this.down('#rally-chart') ) { this.down('#rally-chart').destroy(); }
        if (release){
            this.getBody().removeAll();
            this.setLoading(true);

            var promises = [
                this._fetchData(this.portfolioItemFeature, this.featureFetchFields, this.getReleaseFilters(release)),
                this._fetchData('HierarchicalRequirement', this.storyFetchFields, this.getStoryFilters(release, iteration)),
                this._fetchData('Project', this.projectFetchFields,[])
            ];

            Deft.Promise.all(promises).then({
                scope: this,
                success: function(records){

                    this.logger.log('_fetchData success', records);

                    var calc = Ext.create('Rally.technicalservices.ThreatCalculator',{
                        riskField: this.riskField,
                        currentProjectRef: this.getContext().getProjectRef(),
                        projects: records[2],
                        minAgeThreshhold: this.getSetting('minAgeThreshhold'),
                        maxFeatureAgeThreshhold: this.getSetting('maxFeatureAgeThreshhold'),
                        maxStoryAgeThreshhold: this.getSetting('maxStoryAgeThreshhold'),
                        minPointsThreshhold: this.getSetting('minPointsThreshhold'),
                        featureSizeMultiplier: this.getSetting('featureSizeMultiplier'),
                        storySizeMultiplier: this.getSetting('storySizeMultiplier'),
                        riskMultiplier: this.getSetting('riskMultiplier'),
                        showDataLabels: this.getSetting('showDataLabels'),
                        showDependencyColors: this.getSetting('showDependencyColors'),
                        programRiskSize: this.getSetting('programRiskSize')
                    });

                    calc.runCalculation(records[0],records[1]).then({
                        scope: this,
                        success: function(chartData){
                            this.setLoading(false);
                            this.logger.log('runCalculation success series', chartData)

                            if (chartData && chartData.series && chartData.series.length > 0) {
                                var chart = this.getBody().add({
                                    xtype: 'tsthreatchart',
                                    itemId: 'rally-chart',
                                    loadMask: false,
                                    chartData: chartData,
                                    maxWidth: 600,
                                    title: 'Threat Matrix'

                                });
                                this.getBody().setSize(this.getWidth() * 0.95);
                                this._addLegend(calc.projectLabelColorMap);
                            } else {
                                this.getBody().add({
                                    xtype: 'container',
                                    html: 'No data found.  Please check the Project Scope, Release and/or iteration and try again',
                                    flex: 1,
                                    style: {
                                        textAlign: 'center'
                                    },
                                    align: 'center'
                                });
                            }


                        },
                        failure: function(operation){
                            this.setLoading(false);
                            this.logger.log('failure in runCalcuation');
                        }
                    });
                    },
                failure: function(operation){
                    this.setLoading(false);
                    this.logger.log('_fetchData failure', operation);
                }
            });
        }
    },
    _addLegend: function(colorMap){
        this.logger.log('_addLegend',colorMap);

        if (this.down('#ct-legend')){
            this.down('#ct-legend').destroy();
        }
        var ct_legend = this.add({
            xtype: 'container',
            itemId: 'ct-legend',
            layout: {type: 'vbox'}
        });

        var color_data = [];
        _.each(colorMap, function(color, label){
            color_data.push({color: color, label: label});
        });
        this.logger.log('_addLegend',color_data);
        var ct = ct_legend.add({
            xtype: 'container',
            padding: 10,
            tpl: '<div class="tslegendtext">Projects:  </div><tpl for="."><div class="tslegend" style="background-color:{color}">&nbsp;&nbsp;</div><div class="tslegendtext">&nbsp;&nbsp;{label}</div><span class="tslegendspacer">&nbsp;</span></tpl>'
        });
        ct.update(color_data);

        var ct2 = ct_legend.add({
            xtype: 'container',
            padding: 10,
            html: '<div class="tslegendtext">Types:  </div><div class="tslegend-square">&nbsp;&nbsp;</div><div class="tslegendtext">&nbsp;&nbsp;Feature (Solid)</div><span class="tslegendspacer">&nbsp;</span>' +
                '<div class="tslegend-donut">&nbsp;&nbsp;</div><div class="tslegendtext">&nbsp;&nbsp;Program Level Risk Feature (Solid Donut)</div><span class="tslegendspacer">&nbsp;</span>' +
                '<div class="tslegend-circle">&nbsp;&nbsp;</div><div class="tslegendtext">&nbsp;&nbsp;Story (Translucent)</div><span class="tslegendspacer">&nbsp;</span>' +
                 '<div class="tslegend-hollow-circle">&nbsp;&nbsp;</div><div class="tslegendtext">&nbsp;&nbsp;Predecessor Stories are outlined</div><span class="tslegendspacer">&nbsp;</span>'
        });

        ct.setSize(this.getWidth() *.95);


    },
    _fetchData: function(modelType, fetchFields, filters){
        this.logger.log('_fetchData',modelType, fetchFields, filters);
        var deferred = Ext.create('Deft.Deferred'),
            store = Ext.create('Rally.data.wsapi.Store',{
                model: modelType,
                limit: 'Infinity',
                fetch: fetchFields,
                filters: filters,
                context: {
                    workspace: this.getContext().getWorkspace()._ref,
                    project: this.getContext().getProjectRef(),
                    projectScopeDown: this.getContext().getProjectScopeDown(),
                    projectScopeUp: false
                }
            });

        store.load({
            scope: this,
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation);
                }
            }
        });
        return deferred;
    },
    addComponents: function(){
        this.logger.log('addComponents');
        var release = null, iteration = null;

        if ( this.getSetting('showScopeSelector') || this.getSetting('showScopeSelector') == "true" ) {
            var tb = this.getHeader().add({
                xtype : 'timebox-selector',
                context : this.getContext(),
                width: '75%',
                listeners: {
                    releasechange: function(release){
                        this.onTimeboxScopeChange(release);
                    },
                    iterationchange: function(iteration){
                        this.onTimeboxScopeChange(iteration);
                    },
                    scope: this
                }
            });

            this._addButton();
            this.getHeader().setSize(this.getWidth() * 0.95);
            release = tb.getReleaseRecord();
            iteration = tb.getIterationRecord();
            this.onTimeboxScopeChange(release,iteration);
        } else {

            this._addButton();
            this.getHeader().setSize(this.getWidth() * 0.95);
            //this.onTimeboxScopeChange(release,iteration);
            this.subscribe(this, 'timeboxReleaseChanged', this.onTimeboxScopeChange, this);
            this.subscribe(this, 'timeboxIterationChanged', this.onTimeboxScopeChange, this);
            this.publish('requestTimebox', this);
        }

    },
    _addButton: function(){
        this.getHeader().add({
            xtype: 'rallybutton',
            itemId: 'bt-dependency',
            cls: 'rly-small secondary',
            width: 145,
            iconCls: 'icon-predecessor',
            text: 'Show Dependencies',
            pressedCls: 'rly-small primary',
            scope: this,
            enableToggle: true,
            listeners: {
                scope: this,
                toggle: this._toggleDependencies
            }
         });
    },
    _toggleDependencies: function(btn, showDependencies){
        this.logger.log('_toggleDependencies', showDependencies);

        if (showDependencies){
            btn.addCls('primary');
            btn.removeCls('secondary');
            btn.btnInnerEl.update('Hide Dependencies');
         } else {
            btn.addCls('secondary');
            btn.removeCls('primary');
            btn.btnInnerEl.update('Show Dependencies');
        }

        var chart = this.down('#rally-chart').items.items[1].items.items[0];
        _.each(chart.chart.series, function(s){
            s.data[0].select(showDependencies, showDependencies);
        });
    },
    getIterationRecord: function(){
        return this.selectedIteration;
    },
    getReleaseRecord: function(){
        return this.selectedRelease;
    },
    getHeader: function(){
        this.logger.log('getHeader');

        if (this.down('#ct-header')){
            return this.down('#ct-header');
        }

        return this.add({
            xtype: 'container',
            itemId: 'ct-header',
            layout: {type: 'hbox'}
        });
    },

    getBody: function(){
        this.logger.log('getBody');

        if (this.down('#ct-body')){
            return this.down('#ct-body');
        }
        return this.add({
            xtype: 'container',
            itemId: 'ct-body'
        });
    },

    /********************************************
     /* Overrides for App class
     /*
     /********************************************/
    //getSettingsFields:  Override for App
    getSettingsFields: function() {
        var me = this;

        return [
            {
                name: 'showScopeSelector',
                xtype: 'rallycheckboxfield',
                boxLabelAlign: 'after',
                fieldLabel: '',
                margin: '0 0 25 200',
                boxLabel: 'Show scope selector'
            },
            {
                name: 'maxFeatureAgeThreshhold',
                xtype: 'rallynumberfield',
                fieldLabel: 'Max Feature age threshold (days)',
                labelWidth: 200,
                labelAlign: 'right',
                minValue: 0
            },            {
                name: 'maxStoryAgeThreshhold',
                xtype: 'rallynumberfield',
                fieldLabel: 'Max User Story age threshold (days)',
                labelWidth: 200,
                labelAlign: 'right',
                minValue: 0,
                margin: '0 0 20 0'
            },{
                name: 'minAgeThreshhold',
                xtype: 'rallynumberfield',
                fieldLabel: 'Min age threshold (days)',
                labelWidth: 200,
                labelAlign: 'right',
                 minValue: 0
            },{
                name: 'minPointsThreshhold',
                xtype: 'rallynumberfield',
                fieldLabel: 'Min points threshold',
                labelWidth: 200,
                labelAlign: 'right',
                 minValue: 0
            },{
                name: 'andMinThreshholds',
                xtype: 'rallycheckboxfield',
                boxLabelAlign: 'after',
                fieldLabel: '',
                margin: '0 0 25 200',
                boxLabel: 'Use <b>AND</b> query to exclude items by threshold.<br/><span style="color:#999999;"><i>If checked, exclude artifacts if their age <b>AND</b> points are below the minimum threshold.<br/> If unchecked, exclude artifacts if either age <b>OR</b> points are below the minimum threshold.</i></span>'
            },{
                name: 'featureSizeMultiplier',
                xtype: 'rallynumberfield',
                fieldLabel: 'Feature Size Multiplier',
                labelWidth: 200,
                labelAlign: 'right',
                 minValue: 0
            },{
                name: 'storySizeMultiplier',
                xtype: 'rallynumberfield',
                fieldLabel: 'Story Size Multiplier',
                labelWidth: 200,
                labelAlign: 'right',
                minValue: 0
            },{
                name: 'riskMultiplier',
                xtype: 'rallynumberfield',
                fieldLabel: 'Risk Multiplier for User Stories',
                labelWidth: 200,
                labelAlign: 'right',
                minValue: 0
            },{
                name: 'programRiskSize',
                xtype: 'rallynumberfield',
                fieldLabel: 'Size for Program Level Risk Features',
                labelWidth: 200,
                labelAlign: 'right',
                minValue: 3,
                margin: '0 0 20 0'
            },{
                name: 'showDataLabels',
                xtype: 'rallycheckboxfield',
                boxLabelAlign: 'after',
                fieldLabel: '',
                margin: '0 0 0 200',
                boxLabel: 'Show data labels'
            },{
                name: 'showDependencyColors',
                xtype: 'rallycheckboxfield',
                boxLabelAlign: 'after',
                fieldLabel: '',
                margin: '0 0 0 200',
                boxLabel: 'Show colored dependencies'
            }

        ];
    },
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    //showSettings:  Override
    showSettings: function(options) {
        this._appSettings = Ext.create('Rally.app.AppSettings', Ext.apply({
            fields: this.getSettingsFields(),
            settings: this.getSettings(),
            defaultSettings: this.getDefaultSettings(),
            context: this.getContext(),
            settingsScope: this.settingsScope,
            autoScroll: true
        }, options));

        this._appSettings.on('cancel', this._hideSettings, this);
        this._appSettings.on('save', this._onSettingsSaved, this);
        if (this.isExternal()){
            if (this.down('#settings_box').getComponent(this._appSettings.id)==undefined){
                this.down('#settings_box').add(this._appSettings);
            }
        } else {
            this.hide();
            this.up().add(this._appSettings);
        }
        return this._appSettings;
    },
    _onSettingsSaved: function(settings){
        Ext.apply(this.settings, settings);
        this._hideSettings();
        this.onSettingsUpdate(settings);
    },
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        Ext.apply(this, settings);
        this.addComponents();
    }
});

Ext.define('timebox-selector', {
    extend : 'Ext.Container',
    componentCls : 'app',
    alias : 'widget.timebox-selector',
    cls : 'timebox-selector',
    layout : 'hbox',
    width : '100%',
    mixins : [
        'Rally.Messageable'
    ],
    constructor : function()
    {
        this.stateId = Rally.environment.getContext().getScopedStateId('timebox-filter');
        this.callParent(arguments);
    },
    initComponent : function()
    {
        this.callParent(arguments);
        this._createReleaseCombo();
        this.addEvents('releasechange','iterationchange');
        
        // configured to allow others to ask what the current selection is,
        // in case they missed the initial message
        this.subscribe(this, 'requestTimebox', this._requestTimebox, this);
        
    },
    _createReleaseCombo : function()
    {
        this._releaseCombo = this.add({
            xtype : 'rallyreleasecombobox',
            fieldLabel : 'Program Increment',
            hideLabel : false,
            labelPad : 5,
            labelSeparator : ':',
            labelWidth : 130,
            width : 280,
            labelAlign : 'right',
            stateful : false,
            stateId : 'releasecombo',
            padding : 5,
            context : Rally.environment.getContext(),
            showArrows : false,
            growToLongestValue : true,
            defaultToCurrentTimebox : true,
            listeners : {
                change : function(t, newVal, oldVal, eOpts)
                {
                    var release = t.getRecord();
                    this.fireEvent('releasechange',release);
                    //console.log("Publishing Release:", release);
                    this.publish('timeboxReleaseChanged', release);
                    this._updateIterationCombo(release);
                },
                scope : this
            }
        });
    },
    _updateIterationCombo : function(release)
    {
        this.remove('globaliterationpicker');
        this.fireEvent('iterationchange',null);
        this.publish('timeboxIterationChanged', null);
                    
        var endFilter = Ext.create('Rally.data.wsapi.Filter', {
            property : "EndDate",
            operator : "<=",
            value : Rally.util.DateTime.toIsoString(release.get('ReleaseDate'))
        });
        var startFilter = Ext.create('Rally.data.wsapi.Filter', {
            property : "StartDate",
            operator : ">=",
            value : Rally.util.DateTime.toIsoString(release.get('ReleaseStartDate'))
        });
        var filters = endFilter.and(startFilter);

        this._iterationCombo = this.add({
            xtype : 'rallyiterationcombobox',
            itemId : 'globaliterationpicker',
            fieldLabel : 'Sprint/Iteration',
            hideLabel : false,
            labelPad : 5,
            labelSeparator : ':',
            labelWidth : 100,
            labelAlign : 'right',
            stateful : false,
            padding : 5,
            context : Rally.environment.getContext(),
            showArrows : false,
            growToLongestValue : true,
            stateId : 'iterationcombo',
            allowBlank : true,
            allowClear : true,
            allowNoEntry : true,
            noEntryText : 'PI Scope',
            emptyText : 'PI Scope',
            noEntryValue : null,
            defaultToCurrentTimebox : false,
            defaultSelectPosition : 'first',
            storeConfig : {
                remoteFilter : true,
                filters : filters
            },
            listeners : {
                change : function(t, newVal, oldVal, eOpts)
                {
                    var iteration = t.getRecord();
                    this.fireEvent('iterationchange',iteration);
                    this.publish('timeboxIterationChanged', iteration);
                },
                scope : this
            }
        });
    },
    _requestTimebox : function(source) {
        //console.log('Got request timebox message', source);
        var release = this.getReleaseRecord();
        //console.log('release',release);
        if (release) {
            this.publish('timeboxReleaseChanged', release);
        } 
        
        var iteration = this.getIterationRecord();
        //console.log('iteration', iteration);
        if (iteration) {
            this.publish("timeboxIterationChanged",  iteration);
        }
    },
    getReleaseRecord: function(){
        if (this._releaseCombo){
            return this._releaseCombo.getRecord() || null;
        }
        return null;
    },
    getIterationRecord: function(){
        if (this._iterationCombo){
            return this._iterationCombo.getRecord() || null;
        }
        return null;
    }
});
            
               Rally.launchApp('threat-matrix', {
                   name: 'Threat Matrix'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.tslegend {
    width: 18px;
    height: 14px;
    border-radius: 4px;
    text-align: center;
    color: white;
    border-style: solid;
    border-width: 1px;
    display: inline-block;
}

.tslegendtext {
    font-family: 'Lucida Grande', 'Lucida Sans Unicode', Verdana, Arial, Helvetica, sans-serif;
    font-size: '14px'!important;
    color: #274b6d;
    display: inline
}
.tslegendspacer {
    padding: 15px;
    display: inline;
}

.tslegend-square {
    width: 14px;
    height: 14px;
    text-align: center;
    border-radius: 7px;
    color: rgba(103,103,103,1);;
    background-color: rgba(103,103,103,1);
    border-style: solid;
    border-width: 1px;
    display: inline-block;
}

.tslegend-donut {
    width: 14px;
    height: 14px;
    text-align: center;
    border-radius: 7px;
    border-width: 4px;
    color: rgba(103,103,103,1);
    background-color: #FFFFFF;
    border-style: solid;
    display: inline-block;
}

.tslegend-circle {
    width: 14px;
    height: 14px;
    text-align: center;
    border-radius: 7px;
    color: rgba(103,103,103,.5);
    background-color: rgba(103,103,103,.5);
    border-style: solid;
    border-width: 1px;
    display: inline-block;
}

.tslegend-hollow-circle {
    width: 14px;
    height: 14px;
    text-align: center;
    border-radius: 7px;
    color: black;
    background-color: rgba(103,103,103,.5);
    border-style: solid;
    border-width: 2px;
    display: inline-block;
}

    </style>

</head>
<body></body>
</html>
